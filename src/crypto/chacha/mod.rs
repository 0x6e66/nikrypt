mod state;
mod utils;

use std::vec;

use self::state::chacha20_block;

/// RFC 7539 - Section 2.4.1 - The ChaCha20 Encryption Algorithm
///
/// Pseudocode:
/// ```pseudocode
/// chacha20_encrypt(key, counter, nonce, plaintext):
///     for j = 0 upto floor(len(plaintext)/64)-1
///         key_stream = chacha20_block(key, counter+j, nonce)
///         block = plaintext[(j*64)..(j*64+63)]
///         encrypted_message +=  block ^ key_stream
///     end
///     if ((len(plaintext) % 64) != 0)
///         j = floor(len(plaintext)/64)
///         key_stream = chacha20_block(key, counter+j, nonce)
///         block = plaintext[(j*64)..len(plaintext)-1]
///         encrypted_message += (block^key_stream)[0..len(plaintext)%64]
///     end
///     return encrypted_message
/// end
/// ```
pub fn chacha20_encrypt(
    key: [u8; 32],
    nonce: [u8; 12],
    counter: u32,
    plaintext: Vec<u8>,
) -> Vec<u8> {
    let mut ciphertext: Vec<u8> = vec![];

    for j in 0..plaintext.len() / 64 {
        let key_stream = chacha20_block(key, nonce, counter + j as u32);
        let block = &plaintext[(j * 64)..(j * 64 + 64)];

        assert_eq!(key_stream.len(), 64);
        assert_eq!(key_stream.len(), block.len());

        (0..64).for_each(|i| {
            ciphertext.push(block[i] ^ key_stream[i]);
        });
    }

    if (plaintext.len() % 64) != 0 {
        let j = plaintext.len() / 64;
        let key_stream = chacha20_block(key, nonce, counter + j as u32);
        let block = &plaintext[(j * 64)..plaintext.len()];

        (0..plaintext.len() % 64).for_each(|i| {
            ciphertext.push(block[i] ^ key_stream[i]);
        });
    }

    ciphertext
}

/// RFC 7539 - Section 2.4.1 - The ChaCha20 Encryption Algorithm (reversed)
pub fn chacha20_decrypt(
    key: [u8; 32],
    nonce: [u8; 12],
    counter: u32,
    ciphertext: Vec<u8>,
) -> Vec<u8> {
    chacha20_encrypt(key, nonce, counter, ciphertext)
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_chacha20_encrypt() {
        let key: [u8; 32] = [
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
            0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,
            0x1c, 0x1d, 0x1e, 0x1f,
        ];
        let nonce: [u8; 12] = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4a, 0x00, 0x00, 0x00, 0x00,
        ];
        let counter: u32 = 1;

        let plaintext = "Ladies and Gentlemen of the class of '99: If I could offer you only one tip for the future, sunscreen would be it.".as_bytes().to_vec();

        let ciphertext = chacha20_encrypt(key, nonce, counter, plaintext);

        let valid_ciphertetxt = vec![
            0x6e, 0x2e, 0x35, 0x9a, 0x25, 0x68, 0xf9, 0x80, 0x41, 0xba, 0x07, 0x28, 0xdd, 0x0d,
            0x69, 0x81, 0xe9, 0x7e, 0x7a, 0xec, 0x1d, 0x43, 0x60, 0xc2, 0x0a, 0x27, 0xaf, 0xcc,
            0xfd, 0x9f, 0xae, 0x0b, 0xf9, 0x1b, 0x65, 0xc5, 0x52, 0x47, 0x33, 0xab, 0x8f, 0x59,
            0x3d, 0xab, 0xcd, 0x62, 0xb3, 0x57, 0x16, 0x39, 0xd6, 0x24, 0xe6, 0x51, 0x52, 0xab,
            0x8f, 0x53, 0x0c, 0x35, 0x9f, 0x08, 0x61, 0xd8, 0x07, 0xca, 0x0d, 0xbf, 0x50, 0x0d,
            0x6a, 0x61, 0x56, 0xa3, 0x8e, 0x08, 0x8a, 0x22, 0xb6, 0x5e, 0x52, 0xbc, 0x51, 0x4d,
            0x16, 0xcc, 0xf8, 0x06, 0x81, 0x8c, 0xe9, 0x1a, 0xb7, 0x79, 0x37, 0x36, 0x5a, 0xf9,
            0x0b, 0xbf, 0x74, 0xa3, 0x5b, 0xe6, 0xb4, 0x0b, 0x8e, 0xed, 0xf2, 0x78, 0x5e, 0x42,
            0x87, 0x4d,
        ];

        assert_eq!(ciphertext, valid_ciphertetxt);
    }

    #[test]
    fn test_chacha20_decrypt() {
        let ciphertext = vec![
            0x6e, 0x2e, 0x35, 0x9a, 0x25, 0x68, 0xf9, 0x80, 0x41, 0xba, 0x07, 0x28, 0xdd, 0x0d,
            0x69, 0x81, 0xe9, 0x7e, 0x7a, 0xec, 0x1d, 0x43, 0x60, 0xc2, 0x0a, 0x27, 0xaf, 0xcc,
            0xfd, 0x9f, 0xae, 0x0b, 0xf9, 0x1b, 0x65, 0xc5, 0x52, 0x47, 0x33, 0xab, 0x8f, 0x59,
            0x3d, 0xab, 0xcd, 0x62, 0xb3, 0x57, 0x16, 0x39, 0xd6, 0x24, 0xe6, 0x51, 0x52, 0xab,
            0x8f, 0x53, 0x0c, 0x35, 0x9f, 0x08, 0x61, 0xd8, 0x07, 0xca, 0x0d, 0xbf, 0x50, 0x0d,
            0x6a, 0x61, 0x56, 0xa3, 0x8e, 0x08, 0x8a, 0x22, 0xb6, 0x5e, 0x52, 0xbc, 0x51, 0x4d,
            0x16, 0xcc, 0xf8, 0x06, 0x81, 0x8c, 0xe9, 0x1a, 0xb7, 0x79, 0x37, 0x36, 0x5a, 0xf9,
            0x0b, 0xbf, 0x74, 0xa3, 0x5b, 0xe6, 0xb4, 0x0b, 0x8e, 0xed, 0xf2, 0x78, 0x5e, 0x42,
            0x87, 0x4d,
        ];
        let key: [u8; 32] = [
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
            0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,
            0x1c, 0x1d, 0x1e, 0x1f,
        ];
        let nonce: [u8; 12] = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4a, 0x00, 0x00, 0x00, 0x00,
        ];
        let counter: u32 = 1;

        let plaintext = chacha20_decrypt(key, nonce, counter, ciphertext);

        let valid_plaintext = "Ladies and Gentlemen of the class of '99: If I could offer you only one tip for the future, sunscreen would be it.".as_bytes().to_vec();

        assert_eq!(plaintext, valid_plaintext);
    }
}
